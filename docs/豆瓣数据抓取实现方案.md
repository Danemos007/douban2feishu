# 豆瓣数据抓取实现方案

基于 obsidian-douban 成熟技术方案，实现书籍、电影、电视剧数据抓取

## 1. 数据类型与字段映射

### 1.1 书籍字段
- **Subject ID**: 豆瓣条目唯一ID（从URL提取）
- **我的标签**: 用户自定义标签 `span#rating + next()`
- **我的状态**: wish/do/collect `div#interest_sect_level span.mr10`
- **书名**: JSON-LD中的name字段
- **副标题**: #info中"副标题:"对应值
- **豆瓣评分**: `#interest_sectl strong[property='v:average']`
- **作者**: JSON-LD中author数组
- **我的备注**: 用户评论 `span#rating + next().next().next()`
- **内容简介**: `.intro p` 或 meta[property='og:description']
- **封面图**: meta[property='og:image']
- **我的评分**: `input#n_rating`
- **原作名**: #info中"原作名:"对应值
- **译者**: #info中"译者"链接数组
- **出版年份**: #info中"出版年:"对应值
- **出版社**: #info中"出版社:"对应值
- **标记日期**: `div#interest_sect_level span.mr10 + next()`

### 1.2 电影字段
- **Subject ID**: 豆瓣条目唯一ID
- **我的标签**: 用户自定义标签
- **我的状态**: wish/do/collect
- **类型**: "电影"（固定值，来自type=movie）
- **电影名**: JSON-LD中的name字段
- **封面图**: meta[property='og:image']
- **豆瓣评分**: JSON-LD中aggregateRating.ratingValue
- **我的备注**: 用户评论
- **片长**: JSON-LD中duration
- **上映日期**: JSON-LD中datePublished
- **剧情简介**: JSON-LD中description
- **主演**: JSON-LD中actor数组
- **导演**: JSON-LD中director数组
- **编剧**: #info中"编剧"对应值
- **制片地区**: JSON-LD中countryOfOrigin
- **语言**: #info中"语言"对应值
- **我的评分**: `input#n_rating`
- **标记日期**: 用户标记时间

### 1.3 电视剧/纪录片字段
- **Subject ID**: 豆瓣条目唯一ID
- **我的标签**: 用户自定义标签
- **我的状态**: wish/do/collect
- **类型**: 从页面内容判断（电视剧/纪录片）
- **片名**: JSON-LD中的name字段
- **封面图**: meta[property='og:image']
- **豆瓣评分**: JSON-LD中aggregateRating.ratingValue
- **单集片长**: #info中提取
- **集数**: #info中"集数"对应值
- **首播日期**: JSON-LD中datePublished
- **剧情简介**: JSON-LD中description
- **我的备注**: 用户评论
- **主演**: JSON-LD中actor数组
- **导演**: JSON-LD中director数组
- **编剧**: #info中"编剧"对应值
- **制片地区**: JSON-LD中countryOfOrigin
- **语言**: #info中"语言"对应值
- **我的评分**: `input#n_rating`
- **标记日期**: 用户标记时间

## 2. URL构造策略

```typescript
// 列表页URL
const buildListUrl = (type: 'book' | 'movie-movie' | 'movie-tv', userId: string, status: string, start: number) => {
  const baseParams = `start=${start}&sort=time&rating=all&filter=all&mode=list`;
  
  switch(type) {
    case 'book':
      return `https://book.douban.com/people/${userId}/${status}?${baseParams}`;
    case 'movie-movie':
      return `https://movie.douban.com/people/${userId}/${status}?${baseParams}&type=movie`;
    case 'movie-tv':
      return `https://movie.douban.com/people/${userId}/${status}?${baseParams}&type=tv`;
  }
};

// 详情页URL
const buildDetailUrl = (id: string, type: string) => {
  const domain = type === 'book' ? 'book' : 'movie';
  return `https://${domain}.douban.com/subject/${id}/`;
};
```

## 3. 关键解析代码

### 3.1 JSON-LD结构化数据解析
```typescript
const parseStructuredData = (html: CheerioAPI) => {
  const scripts = html('script[type="application/ld+json"]');
  if (scripts.length > 0) {
    const content = scripts.first().text();
    return JSON.parse(content.replace(/[\r\n\t\s+]/g, ''));
  }
  return null;
};
```

### 3.2 用户状态解析
```typescript
const parseUserState = (html: CheerioAPI) => {
  return {
    rating: html('input#n_rating').val() ? Number(html('input#n_rating').val()) : null,
    tags: parseTagsFromElement(html('span#rating').next().text()),
    state: parseStateFromText(html('div#interest_sect_level span.mr10').text()),
    comment: parseCommentFromSelectors(html),
    markDate: parseDateFromElement(html('div#interest_sect_level span.mr10').next())
  };
};
```

### 3.3 书籍特有信息解析
```typescript
const parseBookDetails = (html: CheerioAPI) => {
  const detailDom = html('#info');
  const valueMap = new Map<string, any>();
  
  detailDom.find('span.pl').each((index, element) => {
    const key = html(element).text().trim();
    let value;
    
    if (key.includes('译者')) {
      value = [];
      html(element.parent).find('a').each((i, a) => {
        value.push(html(a).text().trim());
      });
    } else if (key.includes('作者') || key.includes('出版社') || key.includes('出品方')) {
      value = html(element.next.next).text().trim();
    } else {
      value = html(element.next).text().trim();
    }
    
    valueMap.set(BookKeyMap.get(key), value);
  });
  
  return valueMap;
};
```

## 4. 反爬虫策略实现

```typescript
class AntiSpiderManager {
  private requestCount = 0;
  
  async makeRequest(url: string): Promise<string> {
    // 智能延迟
    await this.intelligentDelay();
    
    // 错误重试
    for (let retry = 0; retry < 3; retry++) {
      try {
        const response = await this.httpRequest(url);
        
        // 人机验证检测
        if (this.isBlocked(response)) {
          throw new Error('遇到人机验证，请重新获取Cookie');
        }
        
        return response;
      } catch (error) {
        if (retry === 2) throw error;
        await this.sleepRange(5000, 10000);
      }
    }
  }
  
  private async intelligentDelay(): Promise<void> {
    this.requestCount++;
    
    if (this.requestCount <= 200) {
      await this.sleepRange(4000, 8000);
    } else {
      await this.sleepRange(10000, 15000);
    }
  }
  
  private isBlocked(html: string): boolean {
    return html.includes('<title>禁止访问</title>');
  }
}
```

## 5. 完整数据抓取流程

```typescript
class DoubanDataScraper {
  async fetchUserData(userId: string): Promise<UserData> {
    const dataTypes = ['book', 'movie-movie', 'movie-tv'];
    const statuses = ['wish', 'do', 'collect'];
    
    const allResults = [];
    
    for (const dataType of dataTypes) {
      for (const status of statuses) {
        // 获取列表页
        const listItems = await this.fetchListPages(dataType, userId, status);
        
        // 获取详情页
        for (const item of listItems) {
          const detail = await this.fetchDetailPage(item.id, dataType);
          allResults.push({
            ...detail,
            userState: item.userState
          });
        }
      }
    }
    
    return { items: allResults };
  }
}
```

## 6. 类型判断逻辑

对于电视剧和纪录片的区分，根据genre（类型）字段判断：

```typescript
const determineContentType = (genres: string[]): 'tv' | 'documentary' => {
  return genres.some(genre => genre.includes('纪录片')) ? 'documentary' : 'tv';
};

// 从JSON-LD和页面解析genres
const parseGenres = (html: CheerioAPI, structuredData: any): string[] => {
  let genres: string[] = [];
  
  // 优先从JSON-LD获取
  if (structuredData?.genre) {
    genres = Array.isArray(structuredData.genre) 
      ? structuredData.genre 
      : [structuredData.genre];
  }
  
  // 补充从#info解析
  const infoText = html('#info').text();
  const genreMatch = infoText.match(/类型:\s*([^\n]+)/);
  if (genreMatch) {
    const additionalGenres = genreMatch[1].split(/\s*\/\s*/);
    genres = [...genres, ...additionalGenres];
  }
  
  return genres;
};
```

## 7. 实现优先级

1. **核心抓取引擎** - Cookie认证、反爬虫、HTML解析
2. **书籍数据抓取** - 相对简单，先实现
3. **电影数据抓取** - JSON-LD解析为主
4. **电视剧数据抓取** - 需要类型判断逻辑
5. **错误处理完善** - Cookie失效、网络异常等

---

*基于 obsidian-douban v2.8.0 源码分析*
*更新时间：2025-08-23*